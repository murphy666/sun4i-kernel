/***************************************************************************
 *
 * This is an AUTOGENERATED file from genio_type_trace_c.pl
 *
 *    CONFIDENTIAL
 *    Copyright (C) Cambridge Silicon Radio Ltd 2007. All rights reserved.
 */

/***************************************************************************
 * Description:
 *       This file is used for debugging the PAL_HCI SAP.  It contains a list
 *       of function that convert enum id into human readable strings.
 *
 * Options used to generate this file:
 * perl genio_type_trace_h.pl
 *       -o /home/bfsw/host/releases/unifi_hostsoftware_212/build/unifi-driver-212/host/lib_sme/sme/../saps/pal_hci_sap/pal_hci_sap_types_trace.c
 *       -x /home/bfsw/host/releases/unifi_hostsoftware_212/build/unifi-driver-212/host/lib_sme/../common/amp_hci/bt_amp_hci.xml
 *       -i PAL_HCI
 *       -d 
 *
 ***************************************************************************/

#include "fsm/csr_wifi_fsm.h" 

#include "sme_trace/sme_trace.h"

#include "pal_hci_sap/pal_hci_sap_types_trace.h"
#include "pal_hci_sap_signals.h"

#ifdef SME_TRACE_ENABLE

#ifndef CSR_UNUSED
#define CSR_UNUSED(x)       (void) x
#endif
char *trace_hci_Buffer(CsrUint8 *buf, CsrUint16 bufLength)
{
    CsrUint8    L1 = 0, strLen=0;
    char *str = CsrPmalloc(bufLength*5);
    for (L1 = 0; L1 < bufLength; L1++)
    {
        strLen += CsrSprintf(&str[strLen],"0x%2x",*(buf+L1)); /*lint !e734    mac_address */
        if (L1==(bufLength-1))
        {
            str[strLen]='\0'; /* End of the buffer */
        }
        else
        {
            str[strLen++]='-'; /* byte seperator */
        }
    }
    /* convert small alpha to big and prepend single digit with zero */
    for (L1=0;L1<strLen;L1++)
    {
        if (str[L1] == ' ')
        {
            /* replace it with zero */
            str[L1] = '0';
        }
    }
    return str;
}

const char *trace_AmpControllerType(AmpControllerType enumIndex)
{
    switch (enumIndex)
    {
        case AMP_CONTROLLER_TYPE_BR_EDR:
            return "BR_EDR";
        case AMP_CONTROLLER_TYPE_802_11:
            return "802_11";
        case AMP_CONTROLLER_TYPE_ECMA_368:
            return "ECMA_368";
        case AMP_CONTROLLER_TYPE_FAKE:
            return "FAKE";
        case AMP_CONTROLLER_TYPE_INVALID:
            return "INVALID";
        default:
            return "ERROR: unrecognised AmpControllerType code";
    }
 }
 
const char *trace_AmpStatus(AmpStatus enumIndex)
{
    switch (enumIndex)
    {
        case AMP_STATUS_AVAILABLE_BUT_PHYSICALLY_POWERED_DOWN:
            return "Available_But_Physically_Powered_Down";
        case AMP_STATUS_ONLY_USED_BY_BLUETOOTH_TECHNOLOGY:
            return "Only_Used_By_Bluetooth_Technology";
        case AMP_STATUS_NO_CAPACITY_AVAILABLE_FOR_BLUETOOTH_OPERATION:
            return "No_Capacity_Available_For_Bluetooth_Operation";
        case AMP_STATUS_LOW_CAPACITY_AVAILABLE_FOR_BLUETOOTH_OPERATION:
            return "Low_Capacity_Available_For_Bluetooth_Operation";
        case AMP_STATUS_MEDIUM_CAPACITY_AVAILABLE_FOR_BLUETOOTH_OPERATION:
            return "Medium_Capacity_Available_For_Bluetooth_Operation";
        case AMP_STATUS_HIGH_CAPACITY_AVAILABLE_FOR_BLUETOOTH_OPERATION:
            return "High_Capacity_Available_For_Bluetooth_Operation";
        case AMP_STATUS_FULL_CAPACITY_AVAILABLE_FOR_BLUETOOTH_OPERATION:
            return "Full_Capacity_Available_For_Bluetooth_Operation";
        default:
            return "ERROR: unrecognised AmpStatus code";
    }
 }
 
const char *trace_HciCommandGroup(HciCommandGroup enumIndex)
{
    switch (enumIndex)
    {
        case HCI_COMMAND_GROUP_OPCODE_MASK:
            return "Opcode_Mask";
        case HCI_COMMAND_GROUP_LINK:
            return "Link";
        case HCI_COMMAND_GROUP_POLICY:
            return "Policy";
        case HCI_COMMAND_GROUP_HOST_BB:
            return "Host_BB";
        case HCI_COMMAND_GROUP_INFO:
            return "Info";
        case HCI_COMMAND_GROUP_STATUS:
            return "Status";
        case HCI_COMMAND_GROUP_TEST:
            return "Test";
        case HCI_COMMAND_GROUP_MAX_OGF:
            return "Max_OGF";
        case HCI_COMMAND_GROUP_OPCODE_GROUP_MASK:
            return "Opcode_Group_Mask";
        default:
            return "ERROR: unrecognised HciCommandGroup code";
    }
 }
 
const char *trace_HciEncryptionEnable(HciEncryptionEnable enumIndex)
{
    switch (enumIndex)
    {
        case HCI_ENCRYPTION_ENABLE_LINK_LEVEL_ENCRYPTION_OFF:
            return "Link_Level_Encryption_Off";
        case HCI_ENCRYPTION_ENABLE_LINK_LEVEL_ENCRYPTION_ON:
            return "Link_Level_Encryption_On";
        default:
            return "ERROR: unrecognised HciEncryptionEnable code";
    }
 }
 
const char *trace_HciEventCode(HciEventCode enumIndex)
{
    switch (enumIndex)
    {
        case HCI_COMMAND_COMPLETE_CODE:
            return "HCI_Command_Complete";
        case HCI_COMMAND_STATUS_CODE:
            return "HCI_Command_Status";
        case HCI_HARDWARE_ERROR_CODE:
            return "HCI_Hardware_Error";
        case HCI_FLUSH_OCCURRED_CODE:
            return "HCI_Flush_Occurred";
        case HCI_LOOPBACK_COMMAND_CODE:
            return "HCI_Loopback_Command";
        case HCI_DATA_BUFFER_OVERFLOW_CODE:
            return "HCI_Data_Buffer_Overflow";
        case HCI_QOS_VIOLATION_CODE:
            return "HCI_QoS_Violation";
        case HCI_ENHANCED_FLUSH_COMPLETE_CODE:
            return "HCI_Enhanced_Flush_Complete";
        case HCI_PHYSICAL_LINK_COMPLETE_CODE:
            return "HCI_Physical_Link_Complete";
        case HCI_CHANNEL_SELECT_CODE:
            return "HCI_Channel_Select";
        case HCI_DISCONNECT_PHYSICAL_LINK_COMPLETE_CODE:
            return "HCI_Disconnect_Physical_Link_Complete";
        case HCI_PHYSICAL_LINK_LOSS_EARLY_WARNING_CODE:
            return "HCI_Physical_Link_Loss_Early_Warning";
        case HCI_PHYSICAL_LINK_RECOVERY_CODE:
            return "HCI_Physical_Link_Recovery";
        case HCI_LOGICAL_LINK_COMPLETE_CODE:
            return "HCI_Logical_Link_Complete";
        case HCI_DISCONNECT_LOGICAL_LINK_COMPLETE_CODE:
            return "HCI_Disconnect_Logical_Link_Complete";
        case HCI_FLOW_SPEC_MODIFY_COMPLETE_CODE:
            return "HCI_Flow_Spec_Modify_Complete";
        case HCI_NUMBER_OF_COMPLETED_DATA_BLOCKS_CODE:
            return "HCI_Number_Of_Completed_Data_Blocks";
        case HCI_SHORT_RANGE_MODE_CHANGE_COMPLETE_CODE:
            return "HCI_Short_Range_Mode_Change_Complete";
        case HCI_AMP_STATUS_CHANGE_CODE:
            return "HCI_AMP_Status_Change";
        case HCI_GENERIC_AMP_LINK_KEY_CODE:
            return "HCI_Generic_AMP_Link_Key";
        case AMP_TRANSMIT_POWER_CODE:
            return "AMP_Transmit_Power";
        case AMP_RECEIVER_REPORT_CODE:
            return "AMP_Receiver_Report";
        case AMP_START_TRANSMITTER_TEST_CODE:
            return "AMP_Start_Transmitter_Test";
        case AMP_START_RECEIVER_TEST_CODE:
            return "AMP_Start_Receiver_Test";
        default:
            return "ERROR: unrecognised HciEventCode code";
    }
 }
 
const char *trace_HciLinkType(HciLinkType enumIndex)
{
    switch (enumIndex)
    {
        case HCI_LINK_TYPE_SYNCHRONOUS_BUFFER:
            return "Synchronous_Buffer";
        case HCI_LINK_TYPE_ACL_BUFFER:
            return "ACL_Buffer";
        default:
            return "ERROR: unrecognised HciLinkType code";
    }
 }
 
const char *trace_HciLoopbackMode(HciLoopbackMode enumIndex)
{
    switch (enumIndex)
    {
        case HCI_LOOPBACK_MODE_NO_LOOPBACK:
            return "No_Loopback";
        case HCI_LOOPBACK_MODE_LOCAL_LOOPBACK:
            return "Local_Loopback";
        case HCI_LOOPBACK_MODE_REMOTE_LOOPBACK:
            return "Remote_Loopback";
        default:
            return "ERROR: unrecognised HciLoopbackMode code";
    }
 }
 
const char *trace_HciOpcode(HciOpcode enumIndex)
{
    switch (enumIndex)
    {
        case HCI_NO_OPERATION_CODE:
            return "HCI_No_Operation";
        case HCI_CREATE_PHYSICAL_LINK_CODE:
            return "HCI_Create_Physical_Link";
        case HCI_ACCEPT_PHYSICAL_LINK_REQUEST_CODE:
            return "HCI_Accept_Physical_Link_Request";
        case HCI_DISCONNECT_PHYSICAL_LINK_CODE:
            return "HCI_Disconnect_Physical_Link";
        case HCI_CREATE_LOGICAL_LINK_CODE:
            return "HCI_Create_Logical_Link";
        case HCI_ACCEPT_LOGICAL_LINK_CODE:
            return "HCI_Accept_Logical_Link";
        case HCI_DISCONNECT_LOGICAL_LINK_CODE:
            return "HCI_Disconnect_Logical_Link";
        case HCI_LOGICAL_LINK_CANCEL_CODE:
            return "HCI_Logical_Link_Cancel";
        case HCI_FLOW_SPEC_MODIFY_CODE:
            return "HCI_Flow_Spec_Modify";
        case HCI_SET_EVENT_MASK_CODE:
            return "HCI_Set_Event_Mask";
        case HCI_RESET_CODE:
            return "HCI_Reset";
        case HCI_FLUSH_CODE:
            return "HCI_Flush";
        case HCI_READ_CONNECTION_ACCEPT_TIMEOUT_CODE:
            return "HCI_Read_Connection_Accept_Timeout";
        case HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_CODE:
            return "HCI_Write_Connection_Accept_Timeout";
        case HCI_READ_LINK_SUPERVISION_TIMEOUT_CODE:
            return "HCI_Read_Link_Supervision_Timeout";
        case HCI_WRITE_LINK_SUPERVISION_TIMEOUT_CODE:
            return "HCI_Write_Link_Supervision_Timeout";
        case HCI_ENHANCED_FLUSH_CODE:
            return "HCI_Enhanced_Flush";
        case HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT_CODE:
            return "HCI_Read_Logical_Link_Accept_Timeout";
        case HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_CODE:
            return "HCI_Write_Logical_Link_Accept_Timeout";
        case HCI_SET_EVENT_MASK_PAGE2_CODE:
            return "HCI_Set_Event_Mask_Page2";
        case HCI_READ_LOCATION_DATA_CODE:
            return "HCI_Read_Location_Data";
        case HCI_WRITE_LOCATION_DATA_CODE:
            return "HCI_Write_Location_Data";
        case HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT_CODE:
            return "HCI_Read_Best_Effort_Flush_Timeout";
        case HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT_CODE:
            return "HCI_Write_Best_Effort_Flush_Timeout";
        case HCI_SHORT_RANGE_MODE_CODE:
            return "HCI_Short_Range_Mode";
        case HCI_READ_LOCAL_VERSION_INFORMATION_CODE:
            return "HCI_Read_Local_Version_Information";
        case HCI_READ_LOCAL_SUPPORTED_COMMANDS_CODE:
            return "HCI_Read_Local_Supported_Commands";
        case HCI_READ_DATA_BLOCK_SIZE_CODE:
            return "HCI_Read_Data_Block_Size";
        case HCI_READ_FAILED_CONTACT_COUNTER_CODE:
            return "HCI_Read_Failed_Contact_Counter";
        case HCI_RESET_FAILED_CONTACT_COUNTER_CODE:
            return "HCI_Reset_Failed_Contact_Counter";
        case HCI_READ_LINK_QUALITY_CODE:
            return "HCI_Read_Link_Quality";
        case HCI_READ_RSSI_CODE:
            return "HCI_Read_RSSI";
        case HCI_READ_LOCAL_AMP_INFO_CODE:
            return "HCI_Read_Local_AMP_Info";
        case HCI_READ_LOCAL_AMP_ASSOC_CODE:
            return "HCI_Read_Local_AMP_ASSOC";
        case HCI_WRITE_REMOTE_AMP_ASSOC_CODE:
            return "HCI_Write_Remote_AMP_ASSOC";
        case HCI_READ_LOOPBACK_MODE_CODE:
            return "HCI_Read_Loopback_Mode";
        case HCI_WRITE_LOOPBACK_MODE_CODE:
            return "HCI_Write_Loopback_Mode";
        case HCI_ENABLE_AMP_TEST_MODE_CODE:
            return "HCI_Enable_AMP_Test_Mode";
        case HCI_SET_AMP_TRANSMIT_POWER_TEST_CODE:
            return "HCI_Set_AMP_Transmit_Power_Test";
        case HCI_ENABLE_AMP_RECEIVER_REPORTS_CODE:
            return "HCI_Enable_AMP_Receiver_Reports";
        case HCI_TRANSMITTER_AMP_TEST_CODE:
            return "HCI_Transmitter_AMP_Test";
        case HCI_RECEIVER_AMP_TEST_CODE:
            return "HCI_Receiver_AMP_Test";
        case HCI_AMP_TEST_END_CODE:
            return "HCI_AMP_Test_End";
        default:
            return "ERROR: unrecognised HciOpcode code";
    }
 }
 
const char *trace_HciServiceType(HciServiceType enumIndex)
{
    switch (enumIndex)
    {
        case HCI_SERVICE_TYPE_NO_TRAFFIC:
            return "No_Traffic";
        case HCI_SERVICE_TYPE_BEST_EFFORT:
            return "Best_Effort";
        case HCI_SERVICE_TYPE_GUARANTEED:
            return "Guaranteed";
        default:
            return "ERROR: unrecognised HciServiceType code";
    }
 }
 
const char *trace_HciStatusCode(HciStatusCode enumIndex)
{
    switch (enumIndex)
    {
        case HCI_STATUS_CODE_SUCCESS:
            return "Success";
        case HCI_STATUS_CODE_UNKNOWN_HCI_COMMAND:
            return "Unknown_HCI_Command";
        case HCI_STATUS_CODE_UNKNOWN_CONNECTION_IDENTIFIER:
            return "Unknown_Connection_Identifier";
        case HCI_STATUS_CODE_HARDWARE_FAILURE:
            return "Hardware_Failure";
        case HCI_STATUS_CODE_PAGE_TIMEOUT:
            return "Page_Timeout";
        case HCI_STATUS_CODE_AUTHENTICATION_FAILURE:
            return "Authentication_Failure";
        case HCI_STATUS_CODE_PIN_OR_KEY_MISSING:
            return "PIN_Or_Key_Missing";
        case HCI_STATUS_CODE_MEMORY_CAPACITY_EXCEEDED:
            return "Memory_Capacity_Exceeded";
        case HCI_STATUS_CODE_CONNECTION_TIMEOUT:
            return "Connection_Timeout";
        case HCI_STATUS_CODE_CONNECTION_LIMIT_EXCEEDED:
            return "Connection_Limit_Exceeded";
        case HCI_STATUS_CODE_SYNCHRONOUS_CONNECTION_LIMIT_TO_A_DEVICE_EXCEEDED:
            return "Synchronous_Connection_Limit_To_A_Device_Exceeded";
        case HCI_STATUS_CODE_ACL_CONNECTION_ALREADY_EXISTS:
            return "ACL_Connection_Already_Exists";
        case HCI_STATUS_CODE_COMMAND_DISALLOWED:
            return "Command_Disallowed";
        case HCI_STATUS_CODE_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES:
            return "Connection_Rejected_Due_To_Limited_Resources";
        case HCI_STATUS_CODE_CONNECTION_REJECTED_DUE_TO_SECURITY_REASONS:
            return "Connection_Rejected_Due_To_Security_Reasons";
        case HCI_STATUS_CODE_CONNECTION_REJECTED_DUE_TO_UNACCEPTABLE_BD_ADDR:
            return "Connection_Rejected_Due_To_Unacceptable_BD_ADDR";
        case HCI_STATUS_CODE_CONNECTION_ACCEPT_TIMEOUT_EXCEEDED:
            return "Connection_Accept_Timeout_Exceeded";
        case HCI_STATUS_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE:
            return "Unsupported_Feature_Or_Parameter_Value";
        case HCI_STATUS_CODE_INVALID_HCI_COMMAND_PARAMETERS:
            return "Invalid_HCI_Command_Parameters";
        case HCI_STATUS_CODE_REMOTE_USER_TERMINATED_CONNECTION:
            return "Remote_User_Terminated_Connection";
        case HCI_STATUS_CODE_REMOTE_DEVICE_TERMINATED_CONNECTION_DUE_TO_LOW_RESOURCES:
            return "Remote_Device_Terminated_Connection_Due_To_Low_Resources";
        case HCI_STATUS_CODE_REMOTE_DEVICE_TERMINATED_CONNECTION_DUE_TO_POWER_OFF:
            return "Remote_Device_Terminated_Connection_Due_To_Power_Off";
        case HCI_STATUS_CODE_CONNECTION_TERMINATED_BY_LOCAL_HOST:
            return "Connection_Terminated_By_Local_Host";
        case HCI_STATUS_CODE_REPEATED_ATTEMPTS:
            return "Repeated_Attempts";
        case HCI_STATUS_CODE_PAIRING_NOT_ALLOWED:
            return "Pairing_Not_Allowed";
        case HCI_STATUS_CODE_UNKNOWN_LMP_PDU:
            return "Unknown_LMP_PDU";
        case HCI_STATUS_CODE_UNSUPPORTED_REMOTE_OR_LMP_FEATURE:
            return "Unsupported_Remote_Or_LMP_Feature";
        case HCI_STATUS_CODE_SCO_OFFSET_REJECTED:
            return "SCO_Offset_Rejected";
        case HCI_STATUS_CODE_SCO_INTERVAL_REJECTED:
            return "SCO_Interval_Rejected";
        case HCI_STATUS_CODE_SCO_AIR_MODE_REJECTED:
            return "SCO_Air_Mode_Rejected";
        case HCI_STATUS_CODE_INVALID_LMP_PARAMETERS:
            return "Invalid_LMP_Parameters";
        case HCI_STATUS_CODE_UNSPECIFIED_ERROR:
            return "Unspecified_Error";
        case HCI_STATUS_CODE_UNSUPPORTED_LMP_PARAMETER_VALUE:
            return "Unsupported_LMP_Parameter_Value";
        case HCI_STATUS_CODE_ROLE_CHANGE_NOT_ALLOWED:
            return "Role_Change_Not_Allowed";
        case HCI_STATUS_CODE_LMP_RESPONSE_TIMEOUT:
            return "LMP_Response_Timeout";
        case HCI_STATUS_CODE_LMP_ERROR_TRANSACTION_COLLISION:
            return "LMP_Error_Transaction_Collision";
        case HCI_STATUS_CODE_LMP_PDU_NOT_ALLOWED:
            return "LMP_PDU_Not_Allowed";
        case HCI_STATUS_CODE_ENCRYPTION_MODE_NOT_ACCEPTABLE:
            return "Encryption_Mode_Not_Acceptable";
        case HCI_STATUS_CODE_LINK_KEY_CAN_NOT_BE_CHANGED:
            return "Link_Key_Can_Not_Be_Changed";
        case HCI_STATUS_CODE_REQUESTED_QOS_NOT_SUPPORTED:
            return "Requested_QoS_Not_Supported";
        case HCI_STATUS_CODE_INSTANT_PASSED:
            return "Instant_Passed";
        case HCI_STATUS_CODE_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED:
            return "Pairing_With_Unit_Key_Not_Supported";
        case HCI_STATUS_CODE_DIFFERENT_TRANSACTION_COLLISION:
            return "Different_Transaction_Collision";
        case HCI_STATUS_CODE_QOS_UNACCEPTABLE_PARAMETER:
            return "QoS_Unacceptable_Parameter";
        case HCI_STATUS_CODE_QOS_REJECTED:
            return "QoS_Rejected";
        case HCI_STATUS_CODE_CHANNEL_CLASSIFICATION_NOT_SUPPORTED:
            return "Channel_Classification_Not_Supported";
        case HCI_STATUS_CODE_INSUFFICIENT_SECURITY:
            return "Insufficient_Security";
        case HCI_STATUS_CODE_PARAMETER_OUT_OF_MANDATORY_RANGE:
            return "Parameter_Out_Of_Mandatory_Range";
        case HCI_STATUS_CODE_ROLE_SWITCH_PENDING:
            return "Role_Switch_Pending";
        case HCI_STATUS_CODE_RESERVED_SLOT_VIOLATION:
            return "Reserved_Slot_Violation";
        case HCI_STATUS_CODE_ROLE_SWITCH_FAILED:
            return "Role_Switch_Failed";
        case HCI_STATUS_CODE_EXTENDED_INQUIRY_RESPONSE_TOO_LARGE:
            return "Extended_Inquiry_Response_Too_Large";
        case HCI_STATUS_CODE_SECURE_SIMPLE_PAIRING_NOT_SUPPORTED_BY_HOST:
            return "Secure_Simple_Pairing_Not_Supported_By_Host";
        case HCI_STATUS_CODE_HOST_BUSY_PAIRING:
            return "Host_Busy_Pairing";
        case HCI_STATUS_CODE_CONNECTION_REJECTED_DUE_TO_NO_SUITABLE_CHANNEL_FOUND:
            return "Connection_Rejected_Due_To_No_Suitable_Channel_Found";
        case HCI_STATUS_CODE_PHYSICAL_LINK_ALREADY_EXISTS:
            return "Physical_Link_Already_Exists";
        default:
            return "ERROR: unrecognised HciStatusCode code";
    }
 }
 
const char *trace_LinkAcceptTimeout(LinkAcceptTimeout enumIndex)
{
    switch (enumIndex)
    {
        case LINK_ACCEPT_TIMEOUT_RANGE_MIN:
            return "Range_Min";
        case LINK_ACCEPT_TIMEOUT_MANDATORY_RANGE_MIN:
            return "Mandatory_Range_Min";
        case LINK_ACCEPT_TIMEOUT_UNIT_IN_MICROS:
            return "Unit_In_MicroS";
        case LINK_ACCEPT_TIMEOUT_RANGE_MAX:
            return "Range_Max";
        default:
            return "ERROR: unrecognised LinkAcceptTimeout code";
    }
 }
 
const char *trace_LinkKeyType(LinkKeyType enumIndex)
{
    switch (enumIndex)
    {
        case LINK_KEY_TYPE_RESERVED_00:
            return "Reserved_00";
        case LINK_KEY_TYPE_RESERVED_01:
            return "Reserved_01";
        case LINK_KEY_TYPE_RESERVED_02:
            return "Reserved_02";
        case LINK_KEY_TYPE_DEBUG_COMBINATION_KEY:
            return "Debug_Combination_Key";
        case LINK_KEY_TYPE_UNAUTHENTICATED_COMBINATION_KEY:
            return "Unauthenticated_Combination_Key";
        case LINK_KEY_TYPE_AUTHENTICATED_COMBINATION_KEY:
            return "Authenticated_Combination_Key";
        case LINK_KEY_TYPE_RESERVED_06:
            return "Reserved_06";
        default:
            return "ERROR: unrecognised LinkKeyType code";
    }
 }
 
const char *trace_LinkLossReasonCode(LinkLossReasonCode enumIndex)
{
    switch (enumIndex)
    {
        case LINK_LOSS_REASON_CODE_UNKNOWN:
            return "Unknown";
        case LINK_LOSS_REASON_CODE_RANGE_RELATED:
            return "Range_Related";
        case LINK_LOSS_REASON_CODE_BANDWIDTH_RELATED:
            return "Bandwidth_Related";
        case LINK_LOSS_REASON_CODE_RESOLVING_CONFLICT:
            return "Resolving_Conflict";
        case LINK_LOSS_REASON_CODE_INTERFERENCE:
            return "Interference";
        default:
            return "ERROR: unrecognised LinkLossReasonCode code";
    }
 }
 
const char *trace_LinkSupervisionTimeout(LinkSupervisionTimeout enumIndex)
{
    switch (enumIndex)
    {
        case LINK_SUPERVISION_TIMEOUT_RANGE_MIN:
            return "Range_Min";
        case LINK_SUPERVISION_TIMEOUT_MANDATORY_RANGE_MIN:
            return "Mandatory_Range_Min";
        case LINK_SUPERVISION_TIMEOUT_UNIT_IN_MICROS:
            return "Unit_In_MicroS";
        case LINK_SUPERVISION_TIMEOUT_RANGE_MAX:
            return "Range_Max";
        case LINK_SUPERVISION_TIMEOUT_DEFAULT_AMP_TIMEOUT_IN_MILLIS:
            return "Default_AMP_Timeout_In_MilliS";
        default:
            return "ERROR: unrecognised LinkSupervisionTimeout code";
    }
 }
 
const char *trace_LocationDomainAware(LocationDomainAware enumIndex)
{
    switch (enumIndex)
    {
        case LOCATION_DOMAIN_AWARE_REGULATORY_DOMAIN_UNKNOWN:
            return "Regulatory_Domain_Unknown";
        case LOCATION_DOMAIN_AWARE_REGULATORY_DOMAIN_KNOWN:
            return "Regulatory_Domain_Known";
        default:
            return "ERROR: unrecognised LocationDomainAware code";
    }
 }
 
const char *trace_LocationDomainOptions(LocationDomainOptions enumIndex)
{
    switch (enumIndex)
    {
        case LOCATION_DOMAIN_OPTIONS_SPACE:
            return "Space";
        case LOCATION_DOMAIN_OPTIONS_LETTER_I:
            return "Letter_I";
        case LOCATION_DOMAIN_OPTIONS_LETTER_O:
            return "Letter_O";
        case LOCATION_DOMAIN_OPTIONS_LETTER_X:
            return "Letter_X";
        default:
            return "ERROR: unrecognised LocationDomainOptions code";
    }
 }
 
const char *trace_LocationOptions(LocationOptions enumIndex)
{
    switch (enumIndex)
    {
        case LOCATION_OPTIONS_NOT_MAINS_POWERED:
            return "Not_Mains_Powered";
        case LOCATION_OPTIONS_MAINS_POWERED:
            return "Mains_Powered";
        default:
            return "ERROR: unrecognised LocationOptions code";
    }
 }
 
const char *trace_PacketType(PacketType enumIndex)
{
    switch (enumIndex)
    {
        case PACKET_TYPE_AUTOMATICALLY_FLUSHABLE_ONLY:
            return "Automatically_Flushable_Only";
        default:
            return "ERROR: unrecognised PacketType code";
    }
 }
 
const char *trace_PowerLevel(PowerLevel enumIndex)
{
    switch (enumIndex)
    {
        case POWER_LEVEL_MINIMUM_POWER:
            return "Minimum_Power";
        case POWER_LEVEL_INCREMENT_POWER:
            return "Increment_Power";
        case POWER_LEVEL_DECREMENT_POWER:
            return "Decrement_Power";
        case POWER_LEVEL_MAXIMUM_POWER:
            return "Maximum_Power";
        case POWER_LEVEL_RESERVED:
            return "Reserved";
        default:
            return "ERROR: unrecognised PowerLevel code";
    }
 }
 
const char *trace_ShortRangeMode(ShortRangeMode enumIndex)
{
    switch (enumIndex)
    {
        case SHORT_RANGE_MODE_DISABLED:
            return "Disabled";
        case SHORT_RANGE_MODE_ENABLED:
            return "Enabled";
        default:
            return "ERROR: unrecognised ShortRangeMode code";
    }
 }
 
const char *trace_TestMode(TestMode enumIndex)
{
    switch (enumIndex)
    {
        case TEST_MODE_DISABLE_AMP_TEST_MODE:
            return "Disable_AMP_test_mode";
        case TEST_MODE_ENABLE_AMP_TEST_MODE:
            return "Enable_AMP_test_mode";
        case TEST_MODE_RESERVED:
            return "Reserved";
        default:
            return "ERROR: unrecognised TestMode code";
    }
 }
 
#endif /* SME_TRACE_ENABLE */

